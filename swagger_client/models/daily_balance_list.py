# coding: utf-8

"""
    finAPI RESTful Services

    finAPI RESTful Services  # noqa: E501

    OpenAPI spec version: v1.42.1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from swagger_client.models.daily_balance import DailyBalance  # noqa: F401,E501
from swagger_client.models.paging import Paging  # noqa: F401,E501


class DailyBalanceList(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'latest_common_balance_timestamp': 'str',
        'daily_balances': 'list[DailyBalance]',
        'paging': 'Paging'
    }

    attribute_map = {
        'latest_common_balance_timestamp': 'latestCommonBalanceTimestamp',
        'daily_balances': 'dailyBalances',
        'paging': 'paging'
    }

    def __init__(self, latest_common_balance_timestamp=None, daily_balances=None, paging=None):  # noqa: E501
        """DailyBalanceList - a model defined in Swagger"""  # noqa: E501

        self._latest_common_balance_timestamp = None
        self._daily_balances = None
        self._paging = None
        self.discriminator = None

        if latest_common_balance_timestamp is not None:
            self.latest_common_balance_timestamp = latest_common_balance_timestamp
        self.daily_balances = daily_balances
        self.paging = paging

    @property
    def latest_common_balance_timestamp(self):
        """Gets the latest_common_balance_timestamp of this DailyBalanceList.  # noqa: E501

        The latestCommonBalanceTimestamp is the latest timestamp at which all given accounts have been up to date. Only balances with their date being smaller than the latestCommonBalanceTimestamp are reliable. Example: A user has two accounts: A (last update today, so balance from today) and B (last update yesterday, so balance from yesterday). The service /accounts/dailyBalances will return a balance for yesterday and for today, with the info latestCommonBalanceTimestamp=yesterday. Since account B might have received transactions this morning, today's balance might be wrong. So either make sure that all selected accounts are up to date before calling this service, or use the results carefully in combination with the latestCommonBalanceTimestamp. The format is 'yyyy-MM-dd HH:mm:ss.SSS' (german time).  # noqa: E501

        :return: The latest_common_balance_timestamp of this DailyBalanceList.  # noqa: E501
        :rtype: str
        """
        return self._latest_common_balance_timestamp

    @latest_common_balance_timestamp.setter
    def latest_common_balance_timestamp(self, latest_common_balance_timestamp):
        """Sets the latest_common_balance_timestamp of this DailyBalanceList.

        The latestCommonBalanceTimestamp is the latest timestamp at which all given accounts have been up to date. Only balances with their date being smaller than the latestCommonBalanceTimestamp are reliable. Example: A user has two accounts: A (last update today, so balance from today) and B (last update yesterday, so balance from yesterday). The service /accounts/dailyBalances will return a balance for yesterday and for today, with the info latestCommonBalanceTimestamp=yesterday. Since account B might have received transactions this morning, today's balance might be wrong. So either make sure that all selected accounts are up to date before calling this service, or use the results carefully in combination with the latestCommonBalanceTimestamp. The format is 'yyyy-MM-dd HH:mm:ss.SSS' (german time).  # noqa: E501

        :param latest_common_balance_timestamp: The latest_common_balance_timestamp of this DailyBalanceList.  # noqa: E501
        :type: str
        """

        self._latest_common_balance_timestamp = latest_common_balance_timestamp

    @property
    def daily_balances(self):
        """Gets the daily_balances of this DailyBalanceList.  # noqa: E501

        List of daily balances for specified accounts and dates range  # noqa: E501

        :return: The daily_balances of this DailyBalanceList.  # noqa: E501
        :rtype: list[DailyBalance]
        """
        return self._daily_balances

    @daily_balances.setter
    def daily_balances(self, daily_balances):
        """Sets the daily_balances of this DailyBalanceList.

        List of daily balances for specified accounts and dates range  # noqa: E501

        :param daily_balances: The daily_balances of this DailyBalanceList.  # noqa: E501
        :type: list[DailyBalance]
        """
        if daily_balances is None:
            raise ValueError("Invalid value for `daily_balances`, must not be `None`")  # noqa: E501

        self._daily_balances = daily_balances

    @property
    def paging(self):
        """Gets the paging of this DailyBalanceList.  # noqa: E501

        Information for pagination  # noqa: E501

        :return: The paging of this DailyBalanceList.  # noqa: E501
        :rtype: Paging
        """
        return self._paging

    @paging.setter
    def paging(self, paging):
        """Sets the paging of this DailyBalanceList.

        Information for pagination  # noqa: E501

        :param paging: The paging of this DailyBalanceList.  # noqa: E501
        :type: Paging
        """
        if paging is None:
            raise ValueError("Invalid value for `paging`, must not be `None`")  # noqa: E501

        self._paging = paging

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, DailyBalanceList):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
