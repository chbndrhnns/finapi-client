# coding: utf-8

"""
    finAPI RESTful Services

    finAPI RESTful Services  # noqa: E501

    OpenAPI spec version: v1.41.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from swagger_client.models.new_transaction import NewTransaction  # noqa: F401,E501


class MockAccountData(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'account_id': 'int',
        'account_balance': 'float',
        'new_transactions': 'list[NewTransaction]'
    }

    attribute_map = {
        'account_id': 'accountId',
        'account_balance': 'accountBalance',
        'new_transactions': 'newTransactions'
    }

    def __init__(self, account_id=None, account_balance=None, new_transactions=None):  # noqa: E501
        """MockAccountData - a model defined in Swagger"""  # noqa: E501

        self._account_id = None
        self._account_balance = None
        self._new_transactions = None
        self.discriminator = None

        self.account_id = account_id
        self.account_balance = account_balance
        if new_transactions is not None:
            self.new_transactions = new_transactions

    @property
    def account_id(self):
        """Gets the account_id of this MockAccountData.  # noqa: E501

        Account identifier  # noqa: E501

        :return: The account_id of this MockAccountData.  # noqa: E501
        :rtype: int
        """
        return self._account_id

    @account_id.setter
    def account_id(self, account_id):
        """Sets the account_id of this MockAccountData.

        Account identifier  # noqa: E501

        :param account_id: The account_id of this MockAccountData.  # noqa: E501
        :type: int
        """
        if account_id is None:
            raise ValueError("Invalid value for `account_id`, must not be `None`")  # noqa: E501

        self._account_id = account_id

    @property
    def account_balance(self):
        """Gets the account_balance of this MockAccountData.  # noqa: E501

        The balance that this account should be set to. Note that when the balance does not add up to the current balance plus the sum of the transactions you pass in the 'newTransactions' field, finAPI will fix the balance deviation with the insertion of an adjusting entry ('Zwischensaldo' transaction).  # noqa: E501

        :return: The account_balance of this MockAccountData.  # noqa: E501
        :rtype: float
        """
        return self._account_balance

    @account_balance.setter
    def account_balance(self, account_balance):
        """Sets the account_balance of this MockAccountData.

        The balance that this account should be set to. Note that when the balance does not add up to the current balance plus the sum of the transactions you pass in the 'newTransactions' field, finAPI will fix the balance deviation with the insertion of an adjusting entry ('Zwischensaldo' transaction).  # noqa: E501

        :param account_balance: The account_balance of this MockAccountData.  # noqa: E501
        :type: float
        """
        if account_balance is None:
            raise ValueError("Invalid value for `account_balance`, must not be `None`")  # noqa: E501

        self._account_balance = account_balance

    @property
    def new_transactions(self):
        """Gets the new_transactions of this MockAccountData.  # noqa: E501

        New transactions that should be imported into the account (maximum 1000 transactions at once). Please make sure that the value you pass in the 'accountBalance' field equals the current account balance plus the sum of the new transactions that you pass here, otherwise finAPI will detect a deviation in the balance and fix it with the insertion of an adjusting entry ('Zwischensaldo' transaction). Please also note that it is not guaranteed that all transactions that you pass here will actually get imported. More specifically, finAPI will ignore any transactions whose booking date is prior to the booking date of the latest currently existing transactions minus 10 days (which is the 'update window' that finAPI uses when importing new transactions). Also, finAPI will ignore any transactions that are considered duplicates of already existing transactions within the update window. This is the case for instance when you try to import a new transaction with the same booking date and same amount as an already existing transaction. In such cases, you might get an adjusting entry too ('Zwischensaldo' transaction), as your given balance might not add up to the transactions that will exist in the account after the update.  # noqa: E501

        :return: The new_transactions of this MockAccountData.  # noqa: E501
        :rtype: list[NewTransaction]
        """
        return self._new_transactions

    @new_transactions.setter
    def new_transactions(self, new_transactions):
        """Sets the new_transactions of this MockAccountData.

        New transactions that should be imported into the account (maximum 1000 transactions at once). Please make sure that the value you pass in the 'accountBalance' field equals the current account balance plus the sum of the new transactions that you pass here, otherwise finAPI will detect a deviation in the balance and fix it with the insertion of an adjusting entry ('Zwischensaldo' transaction). Please also note that it is not guaranteed that all transactions that you pass here will actually get imported. More specifically, finAPI will ignore any transactions whose booking date is prior to the booking date of the latest currently existing transactions minus 10 days (which is the 'update window' that finAPI uses when importing new transactions). Also, finAPI will ignore any transactions that are considered duplicates of already existing transactions within the update window. This is the case for instance when you try to import a new transaction with the same booking date and same amount as an already existing transaction. In such cases, you might get an adjusting entry too ('Zwischensaldo' transaction), as your given balance might not add up to the transactions that will exist in the account after the update.  # noqa: E501

        :param new_transactions: The new_transactions of this MockAccountData.  # noqa: E501
        :type: list[NewTransaction]
        """

        self._new_transactions = new_transactions

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, MockAccountData):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
